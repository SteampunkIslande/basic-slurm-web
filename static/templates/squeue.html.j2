<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slurm Queue Status</title>
    <link rel="stylesheet" href="/static/default.css">
</head>

<body>
    <div class="container">
        <h1>üñ•Ô∏è Slurm Queue Status</h1>

        <div id="error-container"></div>

        <div class="table-container">
            <div id="loading" class="loading">Chargement des donn√©es</div>

            <table id="squeue-table" style="display: none;">
                <thead>
                    <tr id="headers-row">
                        <!-- Headers will be dynamically generated -->
                    </tr>
                    <tr class="filters-row" id="filters-row">
                        <!-- Search inputs will be dynamically generated -->
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Data rows will be dynamically generated -->
                </tbody>
            </table>

            <div id="no-results" class="no-results" style="display: none;">
                Aucun job ne correspond aux crit√®res de recherche.
            </div>
        </div>
    </div>

    <script>
        // Configuration et variables globales
        let jobsData = {};
        let filteredData = {};
        let columnNames = [];

        // Fonction pour afficher les erreurs
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
        }

        // Fonction pour cacher le loading et afficher le tableau
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('squeue-table').style.display = 'table';
        }

        // Fonction pour obtenir une classe CSS pour l'√©tat
        function getStatusClass(state) {
            const stateUpper = state.toUpperCase();
            switch (stateUpper) {
                case 'RUNNING':
                case 'R':
                    return 'status-running';
                case 'PENDING':
                case 'PD':
                    return 'status-pending';
                case 'FAILED':
                case 'F':
                    return 'status-failed';
                case 'CANCELLED':
                case 'CA':
                    return 'status-cancelled';
                case 'COMPLETED':
                case 'CD':
                    return 'status-completed';
                case 'TIMEOUT':
                case 'TO':
                    return 'status-timeout';
                case 'SUSPENDED':
                case 'S':
                    return 'status-suspended';
                case 'CONFIGURING':
                case 'CF':
                    return 'status-configuring';
                default:
                    return '';
            }
        }

        // Fonction pour formater une valeur de cellule
        function formatCellValue(columnName, value) {
            if (columnName === 'STATE') {
                const statusClass = getStatusClass(value);
                return `<span class="status-badge ${statusClass}">${value}</span>`;
            }
            return value;
        }

        // Fonction pour charger les donn√©es depuis l'API
        async function loadData() {
            try {
                // R√©cup√©rer tous les param√®tres de l'URL actuelle
                const currentUrl = new URL(window.location);
                const urlParams = new URLSearchParams(currentUrl.search);

                // S'assurer que le format est d√©fini sur JSON
                urlParams.set('format', 'json');

                // Construire l'URL de l'endpoint avec tous les param√®tres
                const apiUrl = `/squeue?${urlParams.toString()}`;

                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();
                jobsData = data;
                filteredData = { ...data };

                // Extraire les noms de colonnes du premier job
                const firstJobId = Object.keys(data)[0];
                if (firstJobId) {
                    columnNames = Object.keys(data[firstJobId]);
                    generateTable();
                    hideLoading();
                } else {
                    hideLoading();
                    showNoResults();
                }
            } catch (error) {
                console.error('Erreur lors du chargement des donn√©es:', error);
                showError(`Erreur lors du chargement des donn√©es: ${error.message}`);
                hideLoading();
            }
        }

        // Fonction pour g√©n√©rer les en-t√™tes et filtres du tableau
        function generateTable() {
            const headersRow = document.getElementById('headers-row');
            const filtersRow = document.getElementById('filters-row');

            // G√©n√©rer les en-t√™tes
            headersRow.innerHTML = columnNames.map(col => `<th>${col}</th>`).join('');

            // G√©n√©rer les filtres
            filtersRow.innerHTML = columnNames.map(col =>
                `<th><input type="text" class="search-input" placeholder="Rechercher..." data-column="${col}" oninput="filterTable()"></th>`
            ).join('');

            // G√©n√©rer le contenu du tableau
            renderTableBody();
        }

        // Fonction pour rendre le corps du tableau
        function renderTableBody() {
            const tableBody = document.getElementById('table-body');
            const noResults = document.getElementById('no-results');

            const jobIds = Object.keys(filteredData);

            if (jobIds.length === 0) {
                showNoResults();
                return;
            }

            hideNoResults();

            tableBody.innerHTML = jobIds.map(jobId => {
                const job = filteredData[jobId];
                const cells = columnNames.map(col =>
                    `<td>${formatCellValue(col, job[col] || '')}</td>`
                ).join('');
                return `<tr>${cells}</tr>`;
            }).join('');
        }

        // Fonction pour afficher le message "aucun r√©sultat"
        function showNoResults() {
            document.getElementById('no-results').style.display = 'block';
            document.getElementById('table-body').innerHTML = '';
        }

        // Fonction pour cacher le message "aucun r√©sultat"
        function hideNoResults() {
            document.getElementById('no-results').style.display = 'none';
        }

        // Fonction de filtrage du tableau
        function filterTable() {
            const filters = {};

            // R√©cup√©rer tous les filtres actifs
            document.querySelectorAll('.search-input').forEach(input => {
                const column = input.dataset.column;
                const value = input.value.toLowerCase().trim();
                if (value) {
                    filters[column] = value;
                }
            });

            // Filtrer les donn√©es
            filteredData = {};
            Object.keys(jobsData).forEach(jobId => {
                const job = jobsData[jobId];
                let matchesAllFilters = true;

                // V√©rifier chaque filtre
                Object.keys(filters).forEach(column => {
                    const filterValue = filters[column];
                    const cellValue = (job[column] || '').toLowerCase();

                    if (!cellValue.includes(filterValue)) {
                        matchesAllFilters = false;
                    }
                });

                if (matchesAllFilters) {
                    filteredData[jobId] = job;
                }
            });

            // Re-rendre le tableau avec les donn√©es filtr√©es
            renderTableBody();
        }

        // Fonction de rafra√Æchissement automatique
        function startAutoRefresh() {
            // Rafra√Æchir toutes les 30 secondes
            setInterval(async () => {
                try {
                    await loadData();
                } catch (error) {
                    console.error('Erreur lors du rafra√Æchissement automatique:', error);
                }
            }, 30000);
        }

        // Fonction de gestion des erreurs r√©seau
        function handleNetworkError() {
            showError('Impossible de se connecter au serveur. V√©rifiez votre connexion r√©seau.');
        }

        // Fonction pour ajouter des raccourcis clavier
        function addKeyboardShortcuts() {
            document.addEventListener('keydown', function (event) {
                // Ctrl/Cmd + R pour rafra√Æchir
                if ((event.ctrlKey || event.metaKey) && event.key === 'r') {
                    event.preventDefault();
                    location.reload();
                }

                // √âchap pour effacer tous les filtres
                if (event.key === 'Escape') {
                    document.querySelectorAll('.search-input').forEach(input => {
                        input.value = '';
                    });
                    filteredData = { ...jobsData };
                    renderTableBody();
                }
            });
        }

        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function () {
            loadData();
            addKeyboardShortcuts();
            startAutoRefresh();
        });

        // Gestion des erreurs globales
        window.addEventListener('error', function (event) {
            console.error('Erreur globale:', event.error);
        });

        // Gestion des erreurs de fetch
        window.addEventListener('unhandledrejection', function (event) {
            console.error('Promesse rejet√©e:', event.reason);
            if (event.reason instanceof TypeError && event.reason.message.includes('fetch')) {
                handleNetworkError();
            }
        });
    </script>
</body>

</html>